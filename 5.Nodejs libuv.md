# Libuv
- Nodejs gives all js code to v8 engine to execute it and when v8 sees any asynchronous code it offloads it to libuv to wait for response or timer.
- When timer expires it or function get the response the function goes to callback queues.
- Event loop checks if the call stack is empty and if its empty then it takes one function from callback queue and push it to call stack in v8 to execute it further.

## Event Loop
![alt text](img2.png)
- Inner loop is `Microtask Processing` and the outer one is real `Event loop`.

- Before starting of each phase in outer loop it first completes the inner loop (like before timer it runs inner and then timer and after timer it runs inner loop and then the poll phase and so on).

- For every phase in inner or outer loop they have separate callback queues.

- When callbacks gets empty the event loop runs the inner loop and waits on poll phase and when something comes in callback it first runs for poll.

- Unlike browsers event loop which runs repeatedly it waits on poll phase till something gets into callback queues.

## Thread Pool
- These are the software threads present in libuv to process the cpu heavy tasks.
- By default their size is 4 but it can be reset by `process.env.UV_THREADPOOL_SIZE = (NUMBER YOU WANT)`.
- Tasks run in run parallel on different threads.
- Processes which use threadpool are file system operation (fs.read, fs.write, etc.), cryptography (pbkdf2, script, random byte generation), compression (zlib operations), DNS lookups.

> - API calls do not use threadpool because if one client uses one thread for connection then there can be thousands or lakhs of clients at a time which can't be managed so nodejs uses sockets + event driven I/O. Event loop and sockets shares same single thread of OS not of threadpool.<br>
> - Threads of threadpool are allocated to threads of OS by one to one mapping.<br>
> - Also threadpool is only used by cpu heavy or blocking code while api calls are non blocking as when request is send till the system not responded event loop do not sit idle it can run and when system respond it then function is send to callback queue of poll phase of event loop.

- When libuv initiates a network call, the OS creates a single non-blocking `socket` identified by one `file descriptor (fd)`. The socket is registered with the `OS I/O multiplexer` (like epoll). When the server sends data, the kernel receives it as packets, reassembles them into a `TCP byte stream` and stores it in the socketâ€™s receive buffer. The kernel then notifies libuv that the socket is readable, after which libuv schedules the corresponding callback in the poll phase callback queue of the event loop.
### <u>Socket :- </u> 
It is a software structure serve as the endpoint for sending or receiving data. It has complex data structure maintained by os.<br>

It has :-
#### 1. Connection Identifiers :- 
To ensure data reaches correct destination. Every socket has unique combination of 5 values. 
- Protocol :- for the methods of sending or receiving data.
- Local IP address & Port :- your computer's identity for this session.
- Remote IP address & Port :- identity of computer you are linking to.
#### 2. Operational Buffers :- 
Sockets include dedicated memory regions for temporary data.
- Recieve Buffers :- hold incoming data from the network until you program calls.
- Send Buffers :- Stores data you program sent until the network hardware physically transmit it.
#### 3. State Control Meta Data :-
For connection oriented protocols like TCP, socket tracks the session's health and progress.
- Connection State :- current status (like LISTEN, ESTABLISHED, CLOSED, etc.).
- Sequence Numbers :- used by TCP to put incomming packets back in order.
- Flow Control Info :- tracks the "Window Size" (how much the other side can handle) to prevent from overwhelming the receiver.
- Retransmission Timers :- trackes if the packet is lost and needs to be resent.
#### 4.Interface Links :-
